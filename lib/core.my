# Iteration
trait Iter[T]:
    fn next() -> T?

trait RevIter[T]:
    fn next_back() -> T?

trait DoubleEndedIter[T] = Iter[T] + RevIter[T]

import internal::raw_list

@[opaque]
struct List[T]:
    raw_list::RawList[T]

    static fn from(it: Iter[T]) -> Self:
        todo

    static fn empty() -> Self:
        Self(raw_list::RawList[T]::empty())

    @[implicit]
    fn as_bool() -> Bool:
        self.0.len()

    @[implicit]
    fn as_iter() -> Iter[T]:
        i = 0
        while i < self.0.len():
            yield self.0.unsafe_index_unchecked(i)
            i += 1

trait FromIter[T]:
    static fn from(it: Iter[T]) -> Self

fn collect[V -> C: FromIter[V]](it: Iter[V]) -> C:
    C::from(it)

fn try_collect[V, T: Try[V] -> C: FromIter[V]](it: Iter[V]) -> T::AsTry[C]:
    it.try_process(|i| i.collect[C]())

# Numbers
trait Zero:
    static fn zero() -> Self

# TODO: AddAssign[V] is a special trait that may be fulfilled by
# `add_assign(V) -> Void`, or by a mutable binding that is
# `Add[V -> Self]`.
fn sum[V -> Acc: Zero + AddAssign[V] = V](it: Iter[V]) -> Acc:
    result = Acc::zero()
    for value in it:
        result += value
    result

fn try_sum[V, T: Try[V] -> Acc: Zero + AddAssign[V] = V](it: Iter[T]) -> T::AsTry[Acc]:
    it.try_process(|i| i.sum[Acc]())

trait CheckAdd[V]:
    fn check_add(V) -> Self?

fn check_sum[V -> Acc: Zero + CheckAdd[V] = V](it: Iter[V]) -> Acc?:
    result = Acc::zero()
    for value in it:
        result = result.check_add(value)?
    result

# Strings
trait Empty:
    static fn empty() Self

# TODO: separator
# TODO: Can the Str version be made automatic by adding an output step?
# TODO: This version is only for mutable types. Should that be part of the
# name/signature? Is control over Acc necessary?
# TODO: Write some examples of use.
fn join[V -> Acc: Empty + AddAssign[V] = V](it: Iter[V]) -> Acc:
    result = Acc::empty()
    for value in it:
        result += value
    result

fn try_join[V, T: Try[V] -> Acc: Empty + AddAssign[V] = V](it: Iter[T]) -> T::AsTry[Acc]:
    it.try_process(|i| i.join[Acc]())

# TODO: Overload priority.
# TODO: Precalculate storage.
# TODO: Other immutable types also need an intermediate buffer. Can this
# pattern be generalized?
fn join(it: Iter[Str]) -> Str:
    StrBuf::from(it).into_str()

fn try_join[T: Try[Str]](it: Iter[T]) -> T:
    it.try_process(|i| i.join())
