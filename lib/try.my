enum TryResult[V, R]:
    Output(V)
    Residual(R)

trait Try[Output, Residual]:
    # TODO: This type is optional, `?` works without it.
    type WithTryOutput[T]: Try[T, Residual]

    @static
    fn from_output(output: Output) Self

    @static
    fn from_residual(residual: Residual) Self

    fn as_try_result() TryResult[Output, Residual]

fn try_process[T: Try, R](it: Iter[T], f: Fn[Iter[T.Output] -> R]) T.WithTryOutput[R]:
    helper = _try_process_helper(it)
    result = f(helper.iter())
    match helper.residual:
        Some(r) => T.WithTryOutput[S].from_residual(r)
        None => T.WithTryOutput[S].from_output(result)

struct _try_process_helper[T: Try]:
    it: Iter[T]
    residual: T.Residual? = None

    fn iter() -> Iter[T.Output]:
        for value in it:
            match value.as_try_result():
                Output(v) =>
                    yield v
                Residual(r) =>
                    self.residual = Some(r)
                    return
