enum Result[V, E]:
    Ok(V)
    Err(E)

    test implements_try:
        fn f[V, E](x: V ? E) -> V ? E:
            (V ? E)::from_value(x?)

    type AsTry[W] = W ? E

    static fn from_value(value: V) -> Self:
        Ok(value)

    static fn from_error(error: E) -> Self:
        Err(error)

    fn as_result() -> Self:
        self

    fn is_ok() -> Bool:
        self is Ok(_)

    fn map[W](f: Fn[V -> W]) -> W ? E:
        Ok(f(self?))

    fn inspect(f: Fn[V -> Void]) -> Self:
        if self is Ok(v):
            f(v)
        self

    @[implicit]
    fn as_iter() -> Iter[V]:
        if self is Ok(v):
            yield v

    fn value_or(default: V) -> V:
        match self:
            Ok(v) => v
            _ => default

    # TODO: Use the caller location in the panic message.
    # TODO: What msg type to accept? String view? Template string?
    # TODO: Can the default message include the type?
    @[panics]
    fn expect(msg: Str = "Ok") -> V:
        match self:
            Ok(v) => v
            Err(_) => panic("expected ${panic_msg}, found ${self}")

    impl[W] if Self == (W ? E) ? E:
        fn flatten() -> W ? E:
            self?

    impl[W] if Self == (W?) ? E:
        fn transpose() -> (W ? E)?:
            match self:
                Ok(Some(v)) => Some(Ok(v))
                Ok(None) => None
                Err(e) => Some(Err(e))

enum Option[V]:
    Some(V)
    None

    test implements_try:
        fn f[V](x: V?) -> V?:
            (V?)::from_value(x?)

    type AsTry[T] = T?

    fn from_value(value: V) -> Self:
        Some(value)

    fn from_error(error: Void) -> Self:
        None

    fn as_result() -> Result[V, Void]:
        match self:
            Some(v) => Ok(v)
            None => Err(Void)

    fn is_some() -> Bool:
        self is Some(_)

    fn map[V -> W](f: Fn[V -> W]) -> W?:
        Some(f(self?))

    fn inspect(f: Fn[V ->]) -> Self:
        if self is Some(v):
            f(v)
        self

    @[implicit]
    fn as_iter() -> Iter[V]:
        if self is Some(v):
            yield v

    fn value_or(default: V) -> V:
        match self:
            Some(v) => v
            _ => default

    @[panics]
    fn expect(msg: Str = "Some") -> V:
        match self:
            Some(v) => v
            _ => panic("expected ${msg}, found None")

    fn filter(f: Fn[V -> Bool]) -> V?:
        match self:
            Some(v) if f(v) => Some(v)
            _ => None

    fn zip[U](other: U?) -> (T, U)?:
        match self, other:
            Some(v), Some(w) => Some((v, w))
            _ => None

    fn xor(other: V?) -> V?:
        match self, other:
            Some(v), None => Some(v)
            None, Some(v) => Some(v)
            _ => None

    impl[W] if Self == (W ? E)?:
        fn transpose() -> (W?) ? E:
            match self:
                Some(Ok(v)) => Ok(Some(v))
                Some(Err(e)) => Err(e)
                None => Ok(None)
