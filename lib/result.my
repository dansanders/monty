# TODO: Comparison operators.
enum Result[V, E]:
    Ok(V)
    Err(E)

    test implements_try:
        fn f[V, E](x: V ? E) -> V ? E:
            (V ? E).from_value(x?)

    type AsTry[T] = T ? E

    static fn from_value(value: V) -> Self:
        Ok(value)

    static fn from_error(error: E) -> Self:
        Err(error)

    fn as_result() -> Self:
        self

    fn is_ok() -> Bool:
        self is Ok(_)

    fn map[W](f: Fn[V -> W]) -> W ? E:
        Ok(f(self?))

    fn inspect(f: Fn[V -> Void]) -> Self:
        if self is Ok(v):
            f(v)
        self

    @[implicit]
    fn as_iter() -> Iter[V]:
        if self is Ok(v):
            yield v

    fn value_or(default: V) -> V:
        match self:
            Ok(v) => v
            _ => default

    # TODO: Use the caller location in the panic message.
    # TODO: What msg type to accept? String view? Template string?
    fn value_or_panic(msg: str = "unexpected Err") -> V:
        match self:
            Ok(v) => v
            Err(e) => panic("$(msg): $(e:?)")

impl[V, E] -> (V ? E) ? E:
    fn flatten() -> V ? E:
        t?

enum Option[V]:
    Some(V)
    None

    test implements_try:
        fn f[V](x: V?) -> V?:
            (V?).from_value(x?)

    type AsTry[T] = T?

    fn from_value(value: V) -> Self:
        Some(value)

    fn from_error(error: Void) -> Self:
        None

    fn as_result() -> Result[V, Void]:
        match self:
            Some(v) => Ok(v)
            None => Err(Void)

    fn is_some() -> Bool:
        self is Some(_)

    fn map[V -> W](f: Fn[V -> W]) -> W?:
        Some(f(self?))

    fn inspect(f: Fn[V ->]) -> Self:
        if self is Some(v):
            f(v)
        self

    @[implicit]
    fn as_iter() -> Iter[V]:
        if self is Some(v):
            yield v

    fn value_or(default: V) -> V:
        match self:
            Some(v) => v
            _ => default

    fn value_or_panic(msg: str = "unexpected None") -> V:
        match self:
            Some(v) => v
            _ => panic(msg)

    fn filter(f: Fn[V -> Bool]) -> V?:
        match self:
            Some(v) if f(v) => Some(v)
            _ => None

    fn zip[U](other: U?) -> (T, U)?:
        match self, other:
            Some(v), Some(w) => Some((v, w))
            _ => None

    fn xor(other: V?) -> V?:
        match self, other:
            Some(v), None => Some(v)
            None, Some(v) => Some(v)
            _ => None

impl[V, E] -> (V ? E)?:
    # TODO: Is `V? ? E` acceptable?
    fn transpose() -> (V?) ? E:
        match self:
            Some(Ok(v)) => Ok(Some(v))
            Some(Err(e)) => Err(e)
            None => Ok(None)

impl[V, E] -> (V?) ? E:
    fn transpose() -> (V ? E)?:
        match self:
            Ok(Some(v)) => Some(Ok(v))
            Ok(None) => None
            Err(e) => Some(Err(e))
