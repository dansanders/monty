@[opaque]
struct Decimal:
    digits: Span[Int8]

    @[implicit]
    static fn from(value: Int) -> Self:
        # TODO: Implement sign.
        expect value >= 0

        result_digits = List[Int8]::empty()
        while value:
            value, digit = value.div_mod(10)
            result_digits.append(digit)

        Self(result_digits.move_to_span())

    static fn zero() -> Self:
        Self(Span[Int8]::empty())

    @[rel(parse)]
    static fn try_parse(digits: Bytes) -> Self?:
        result_digits = List[Int8]::empty()
        for byte in digits.lstrip('0').rev():
            result_digits.append(Int8::try_parse(byte)?)

        Some(Self(result_digits.move_to_span()))

    @[panics, rel(try_parse)]
    static fn parse(digits: Bytes) -> Self:
        Self::try_parse(digits).expect()

    static fn add(a: Self, b: Self) -> Self:
        var a = a.digits
        var b = b.digits
        if a.len() < b.len():
            a, b = b, a

        result_digits = List[Int8]::empty()
        carry = 0_i8
        for i in 0.up_to(b.len() - 1):
            total = a[i] + b[i] + carry
            # TODO: Explicit comparison rather than division, if the compiler
            # isn't smart enough.
            carry, digit = total.div_mod(10)
            result_digits.append(digit)

        for i in b.len().up_to(a.len() - 1):
            total = a[i] + carry
            carry, digit = total.div_mod(10)
            result_digits.append(digit)

        if carry:
            expect carry == 1_i8
            result_digits.append(carry)

        Self(result_digits.move_to_span())

    static fn shr(a: Self, b: Int) -> Self:
        # TODO: Should negative shifts be supported?
        expect b >= 0

        # TODO: Handle large shifts.
        Self(a.digits.slice(b))

    @[implicit]
    fn to_bool() -> Bool:
        self.digits.len()

    fn len() -> Int:
        self.digits.len()

    @[rel(to_int)]
    fn try_to_int() -> Int?:
        result = 0
        for digit in self.digits.rev():
            # TODO: Is it faster to compare the value up front?
            result = 10.check_mul(result)?.check_add(digit)?
        Some(result)

    @[panics, rel(try_to_int)]
    fn to_int() -> Int:
        self.try_to_int().expect()
