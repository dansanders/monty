@opaque
struct Decimal:
    digits: FrozenList[Int8]

    @static
    @implicit
    fn from(value: Int) -> Self:
        # TODO: Implement sign.
        expect value >= 0

        result_digits = List[Int8].empty()
        while value:
            value, digit = value.div_mod(10)
            result_digits.append(digit)

        Self(result_digits.into_frozen_list())

    @static
    fn zero() -> Self:
        Self(FrozenList[Int8].empty())

    @static
    fn try_parse(digits: Bytes) -> Self?:
        result_digits = List[Int8].empty()
        for byte in digits.lstrip('0').rev():
            result_digits.append(Int8.try_parse(byte)?)

        Some(Self(result_digits.into_frozen_list()))

    @static
    fn add(a: Self, b: Self) -> Self:
        var a = a.digits
        var b = b.digits
        if a.len() < b.len():
            a, b = b, a

        result_digits = List[Int8].empty()
        carry = 0_i8
        for i in 0.up_to(b.len() - 1):
            total = a[i] + b[i] + carry
            # TODO: Explicit comparison rather than division, if the compiler
            # isn't smart enough.
            carry, digit = total.div_mod(10)
            result_digits.append(digit)

        for i in b.len().up_to(a.len() - 1):
            total = a[i] + carry
            carry, digit = total.div_mod(10)
            result_digits.append(digit)

        if carry:
            expect carry == 1_i8
            result_digits.append(carry)

        Self(result_digits.into_frozen_list())

    @static
    fn shr(a: Self, b: Int) -> Self:
        # TODO: Should negative shifts be supported?
        expect b >= 0

        # TODO: Handle large shifts.
        Self(a.digits.slice(b))

    @implicit
    fn as_bool() -> Bool:
        self.digits.len()

    fn len() -> Int:
        self.digits.len()

    fn try_as_int() -> Int?:
        result = 0
        for digit in self.digits.rev():
            # TODO: Is it faster to compare the value up front?
            result = 10.check_mul(result)?.check_add(digit)?
        Some(result)
