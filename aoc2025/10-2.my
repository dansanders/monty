use std.linear_program

let data1 = embed_str("data/10-example.txt")
let data2 = embed_str("data/10.txt")
let data = data2

fn parse_button(button: Str) -> Int:
    button
        .remove_affixes("(", ")")
        .split(",")
        .map(Int.parse)

fn parse_joltages(joltages: Str) -> Int:
    joltages
        .remove_affixes("{", "}")
        .map(Int.parse)

fn main() -> Void:
    total = 0
    for line in data.lines():
        _, *button_strs, joltages_str = line.split(" ")
        buttons = button_strs.map(parse_button)
        joltages = joltages_str.parse_joltages()

        presses_var = LPInt.const(0)
        joltage_vars = Array.new(joltages.len(), |i| LPInt.const(0))
        for i, button in buttons.enumerate():
            button_var = LPInt.new("b${i}", min: 0)
            presses_var += button_var
            for j in button:
                joltage_vars[j] += button_var

        problem = LPProblem.minimize(presses_var)
        for i, joltage in joltages.enumerate():
            problem.add_constraint(joltage_vars[i] == joltage)

        match problem.solve():
            Optimal(presses) => total += presses
            _ => unreachable
    print(total)
